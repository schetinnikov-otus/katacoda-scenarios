Теперь обсудим тип сервиса NodePort. NodePort иногда используется для того, чтобы получить доступ к сервисам извне. Для этого должен существовать внешний балансировщик. Мы в нашей демонстрации не будем ставить балансировщик и настраивать его, лишь убедимся, что при обращениях на порт ноды будет отвечать наше приложение. 

Итак, прежде всего изменим тип существующего сервиса на NodePort. Для этого обновим файл service.yaml 

**Нажимаем на кнопку copy to editor.**

И применяем манифест командой  **kubectl apply -f service.yaml**

Во **второй вкладе** можем увидеть обновленный статус сервиса:

`TYPE` изменился на `NodePort`, а в `PORT` появился порт ноды.

Давайте с вами убедимся, что при обращении по этому *порту* на любую из *нод* будет отвечать наше приложение. 

Получить порт ноды и сохранить его в переменной окружени можно с помощью формата вывода jsonpath команды kubectl get.  

Получим полную информацию об объекте Service в формате json

**Запускаем команду**

Смотрим, где именно в json находится информация с nodePort. И через jsonpath запрашиваем только его. 

**Запускаем команду.**

Ага, все верно.

**Сохраняем в переменную окружения**:

 Теперь давайте обратимся по порту NodePort с помощью команды curl. Сделаем запрос на обе ноды - на управляющую и на рабочую. 

Начнем с рабочей ноды. 

**Запускаем команду.**

Видим ответ нашего приложения от одного из подов. 

И теперь **запускаем команду** для запроса к управляющей ноде

И опять-таки идим ответ нашего приложения от одного из подов. 

Таким образом мы посмотрели, как работает тип сервиса NodePort.

Давайте теперь посмотрим, как работает LoadBalancer.