Теперь давайте посмотрим на тип LoadBalancer. Если  сервис имеет тип LoadBalancer, это значит, что нашему *сервису* будет назначен внешний по отношению к кластеру Kubernetes IP. Работает этот тип, только если есть соответствующий облачный контроллер. В катакоде по счастью он есть, и мы сможем увидеть его работу.

Обновим тип сервиса в файле service.yaml. 

**Нажимаем кнопку copy to editor.**

**Применяем манифест** командой `kubectl apply -f service.yaml`

Смотрим настройки сервиса **во второй вкладке**. 

`TYPE` изменился на `LoadBalancer`, а в `EXTERNAL-IP`  получил конкретное значение

Давайте с вами убедимся, что при обращении по этому *IP* по порту `9000` будет отвечать наше приложение. Получить внешний IP и сохранить его в переменной окружени можно с помощью формата вывода jsonpath команды kubectl get.  

**Запускаем команду**

Давайте сделаем запрос с помощью curl на этот IP и порт `9000`:

**Запускаем команду**

Видим ответ нашего приложения от одного из подов. 

Теперь давайте запустим в бесконечном цикле, и посмотрим, как будет происходить перераспределение запросов на поды. 

**Запускаем команду** 

Действительно получаем запросы от разных подов. 
Выйти из  цикла можно с помощью сочетания клавиш **Ctrl - C**

Итак мы с вами посмотрели как работает сервис типа LoadBalancer.

