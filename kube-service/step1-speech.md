 Итак мы все подготовили и можем приступать к изучению объекта типа Service в Kubernetes. Service – это объект, который описывает некоторый набор подов в качестве сетевого сервиса, а также способ доступа к этому сетевому сервису. В самом простом случае создается некоторый "виртуальный" IP, при обращении на который, трафик распределяется по подам.

Давайте с вами развернем приложение, которые мы использовали в предыдущих демонстрациях. А потом создадим для него сервис.  

Создадим файл deployment.yaml с описанием деплоймента. Деплоймент взят из предыдущей демонстрации, останавливаться на нем мы не будем. 

**Нажмем на copy to editor**

И создадим файл service.yaml с описанием сервиса. 

**Нажимаем на copy to editor**

В файле мы описываем объект типа Service, с именем hello-service. Селектор указывает на то, какие поды попадут в балансировку в сервисе. Мы используем селектор app=hello-demo, чтобы в балансировку попали поды деплоймента определенного выше. 

Переопределяем порты. Т.е. запросы к сетевому сервису на 9000ый порт будут приходить на 8000ый порт подов.  

Тип сервиса - ClusterIP. 

Т.е. в нашем случае представленная спецификация сервиса означает, что будет создан внутренний IP, при обращений на который по порту 9000, запросы будут проксироваться на один из подов, у которых есть метка app=hello-demo, на порт 8000 контейнера.

**Применим манифесты командой** `kubectl apply -f deployment.yaml -f service.yaml`

**Во втором терминале** можем наблюдать за тем, как создаются *поды*. 

Дождемся, пока деплоймент раскатится - т.е. когда все *поды* окажутся в статусе Running.

Посмотреть состояние сервиса можно с помощью команды kubectl describe service hello-service

**Запускаем ее** 

Команда выведет информацию о сервисе. Имя, селектор, тип, внутренний IP адрес, порты. Из интересного, можно увидеть список конкретных ip подов, на которые будет направляться трафик в поле Endpoints.

Можно убедится, что это именно поды нашего деплоймента. 

Если запустим команду kubectl get pods -owide. Параметр owide используется для расширенного вывода. В выводе сможем увидеть ip адреса подов. 

**Запускаем команду** 

И да, действительно, в Endpoints именно ip адреса подов. 





Мы также могли создать сервис, используя императивную команду `kubectl expose deployment`. Давайте создадим **сервис** с именем `hello-service-2` для нашего *деплоймента* `hello-deployment` 

**Запускаем команду.** 

В команде из параметров только название деплоймента, тип сервиса и имя сервиса. При создании сервиса селектор подставляется из деплоймента, а переопределения портов не происходит. 

Давайте убедимся в этом и посмотрим настройки созданного сервиса, с помощью команды kubectl describe svc hello-service-2

**Запускаем ее.**

Получили сервис с другим IP, без форвардинга портов, но теми же самыми Endpoints:

Теперь удалим этот сервис, чтобы он нам не мешал. С помощью команды kubectl delete svc hello-service-2. 

**Запускаем команду.** 

Возвращаемся к нашему сервису. Давайте с вами убедимся, что  при добавлении новых подов, сервис будет их подхватывать и включать в балансировку. 

Обновляем количество реплик с 2 до 3 в манифесте деплоймента. 

**Нажием copy to editor.** 

**Применяем манифест** kubectl apply -f deployment.yaml

**Смотрим в Endpoints.**

И новый под действительно добавился в Endpoints

Поскольку сервис реализуется с помощью правил маршрутизации трафика на iptables, то мы можем посмотреть, какие правила прописаны для нашего сервиса. Для этого воспользуемся командой iptables-save | grep hello-service. 

**Запускаем команду.** 

Видим с вами правила, относящиеся к нашему сервису, и можем убедится, что при обращении на внутренний ip сервиса, трафик будет распределятся на ip подов. 

Итак мы с вами научились базовым командам для работы с сервисом в Kubernetes. Теперь давайте посмотрим на то, как работают различные типы сервисов - ClusterIP, NodePort, LoadBalancer.