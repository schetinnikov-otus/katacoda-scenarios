## Kubectl 

**Kubectl** - это утилита, которая позволяет управлять кластером **Kubernetes**. **kubectl** можно использовать для развертывания приложений, проверки и управления ресурсов кластера, а также для просмотра логов.

**Kubectl** работает как клиент к **API Server**-y, т.е. все команды в конечном итоге превращаются в запросы к **API Server**-y, поэтому необходимо, чтобы **kubectl** был сконфигурирован и имел доступ к **API Server**. 

Проверить, настроен ли **kubectl**, можно с помощью команды: 

`kubectl cluster-info`{{execute T1}}

## Получение ресурсов Kubernetes

Поскольку конфигурирование и работа с кластером представляет с собой работу с объектами **Kubernetes**, то **kubectl** заточен под работу с объектами. 

Для каждого объекта Kubernetes есть соответствующий ресурс **API** в **API Server**-e. Чтобы посмотреть список всех зарегистрированных ресурсов и соответствующих им объектов, можно запустить команду

`kubectl api-resources`{{execute T1}}

Как видим, ресурсов и типов объектов довольно много. Какие-то из них привязываются к пространству имен, какие-то нет. Те объекты, которые отвечают за "глобальные" части кластера и сильно связаны, например, с инфраструктурой, как объекты типа **Node**, вынесены из пространств имено. Кстати, пространство имен является объектом **Kubernetes**.

Для того, чтобы получить список объектов в табличном виде можно использовать команду `kubectl get {название ресурса}`

Например, список нод:

`kubectl get nodes`{{execute T1}}

Или статус компонент:

`kubectl get componentstatus`{{execute T1}}

Или список пространств имен:

`kubectl get namespaces`{{execute T1}}

Или список под:

`kubectl get pod`{{execute T1}}

Для того, чтобы получить только один объект в табличном виде можно использовать команду `kubectl get {название ресурса} {имя ресурса}`

Например, `kubectl get node controlplane`{{execute T1}}

Также можно получить не табличное, а полноценное представление в **json** или **yaml** формате, если передать параметр `-o json` или `-o yaml`:

`kubectl get nodes controlplane -o json`{{execute T1}}

`kubectl get nodes controlplane -o yaml`{{execute T1}}

А чтобы получить расширенное, человекочитаемое описание объекта, можно использовать команду `kubectl describe {название ресурса} {имя ресурса}`

Опять-таки для ноды:

`kubectl describe node controlplane`{{execute T1}}

В командах можно использовать помимо множественного и единственного числа ресурсов - **node** и **nodes**, **pod** и **pods** и т.д., использовать сокращения. Например, **po** вместо **pods**, **no** вместо **nodes**. Не для всех ресурсов есть сокращения, а чтобы посмотреть для кого есть и каковы они, можно посмотреть в соответствующей колонке команды `kubectl api-resources`. 

`kubectl get no controlplane`{{execute T1}}

`kubectl get no`{{execute T1}}

`kubectl get ns`{{execute T1}}

`kubectl get po`{{execute T1}}

Также можно получить несколько ресурсов за раз, перечислив их через запятую, например:

`kubectl get no,ns`{{execute T1}}

Т.к. для идентификации объектов помимо типа ресурса и имени, еще необходимо пространство имен, то в **kubectl** есть текущий **namespace**, который задается в настройках конфигурации **kubectl**. Если мы хотим работать с объектами из другого **namespace**-a, **kubectl** нужно передать параметр `-n {имя пространства имен}`. По умолчанию используется **namespace** с именем **default**.

В текущем пространстве имен нет объектов типа **pod**:

`kubectl get po`{{execute T1}}

А вот в системном **kube-system** их много:

`kubectl get po -n kube-system`{{execute T1}}

Также можно посмотреть, что объекты типа **Service** также отличаются в разных пространствах имен: 

> За что отвечает объект Service, мы с вами поговорим позже, а пока просто воспринимаем его как еще один из множества объектов и ресурсов Kubernetes

`kubectl get service`{{execute T1}}

`kubectl get service -n kube-system`{{execute T1}}

A команды `kubectl get service -n default`{{execute T1}} и `kubectl get service`{{execute T1}} идентичны, потому что в конфиге **kubectl** пространством имен по умолчанию является **default**.

## Создание рабочей нагрузки 

Давайте с вами создадим пространство имен и пропишем **namespace** по умолчанию в настройки **kubectl**. До этого мы использовали только команды, с помощью которых мы получали информацию. Для изменения объектов, мы можем использовать команды **kubectl create** - для создания, **kubectl edit** / **kubectl patch** - для редактирования, **kubectl delete** - для удаления.

Создадим новое пространство имен:

`kubectl create ns myapp`{{execute T1}}

Убедимся, что новый объект появился:

`kubectl get ns`{{execute T1}}

И с помощью команды `kubectl config` установим пространство имен по умолчанию в **myapp**.

`kubectl config set-context --current --namespace=myapp`{{execute}}

Давайте контейнер, который мы с вами запускали до этого, теперь запустим с помощью команды `kubectl create`. Для изменения и создания объектов, используют команды **kubectl**, которые берут на вход описание объектов.

`kubectl create -f {файл с описанием объекта}` - для создания объектов
`kubectl apply -f {файл с описанием объекта}` - для обновления объектов 
`kubectl delete -f {файл с описанием объекта}` - для удаления объекта

Описание объекта может быть в различных форматах - **json**, **yaml** и т.д.

Мы можем воспользоваться описанием ресурса в файле **hello-service.json** и создать объект типа **Pod** с помощью команды:

`kubectl create -f hello-service.json`{{execute T1}}

Также можно использовать команду

`kubectl apply -f hello-service.json`{{execute T1}}

Внутри **kubectl** на основе текущего пространства имен и по стандартным для описания объекта полям - **apiVersion**, **kind**, **metadata.name** находит соответствующий ресурс в API **API Server**-a и совершает запросы. И запрос, который сделает **kubectl** будет равносилен запросу, который мы с вами до этого делали напрямую в **API Server**. 

Теперь можем посмотреть на статус объекта типа **Pod**:

`kubectl get po hello-demo`{{execute T1}}

И удалить ресурс, отвечающий за нагрузку с помощью команды

`kubectl delete po hello-demo`{{execute T1}}

Это будет практически равносильно тому запросу, который мы делали до этого в **API Server**.

Итак, мы с вами посмотрели базовые возможности команды **kubectl** по просмотру, созданию, редактированию и удалению объектов. И мы довольно много говорили о объектах типа **Pod**. Давайте же теперь рассмотрим более детально, как они работают, и какие дополнительные возможности **kubectl** предлагает по работе с ними.
