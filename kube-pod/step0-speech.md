Сначала запустим кластер Kubernetes. Для этого нужно дождаться выполнения команды`./launch_k8s.sh`.

**Запускаем команду.** И ждем 

Посмотрим, на скольких нодах у нас развернут кластер: 

**Запускаем команду** `kubectl get node`

Кластер у нас небольшой, состоит из двух нод - одной управляющей ноды и одной рабочей. Управляющая нода имеет имя хоста - controlplane, а рабочая - node01.

Давайте посмотрим список namespace-ов:

**Запускаем команду** `kubectl get namespace`

Видим несколько системных namespace-ов, в частности `kube-system`, в котором запущены основные управляющие компоненты кластера Kubernetes. Они запущены в виде подов. Список под в пространстве имен `kube-system`, можно посмотреть с помощью команды kubectl get pods -n kube-system

**Запустим эту команду.**

Видим, что помимо стандартных управляющих комопнент, присутствуют сетевой плагин - flannel, компонент для работы с DNS - coredns и т.д. Т.е. это те же самые компоненты, которые мы с вами видели в самом докере в предыдущих демо.  

Давайте с вами создадим свой namespace myapp, в котором будем работать с помощью команды `kubectl create namespace myapp`

**Запустим команду.**

Чтобы каждый раз не вводить название namespace-а в командах kubectl изменим контекст с помощью команды kubectl config. 

**Запускаем команду и очищаем терминал.**

Давайте создадим под, для этого воспользуемся простейшим приложением на Python, которые мы с вами использовали в прошлых демо.  Это приложение на запрос по:

- / отдает текст `Hello world from {имя хоста}!`
- А на /version отдает версию приложения

Для этого создадим файл pod.yaml с простейшим описанием объекта типа Pod. Для этого **нажмем на кнопку "Copy to editor"**.

Файл создался. Формат объекта Pod прост. Есть несколько стандартных атрибутов: apiVersion, kid, metadata.name и spec. В spec описание массива контейнеров пода. У нас один контейнер с именем hello-demo и образом из Docker-hub, которое разворачивается на 8000 порту. 

С yaml форматом следует быть аккуратным, т.к. отступы являются значимыми, и один лишний пробел может "испортить" файл.

Для того, чтобы отслеживать статус подов, которые находятся в нашем namespace-е в соседнем терминале запустим команду watch kubectl get pods. В силу особенностей работы Катакоды, для этого нужно будет нажать 2 раза на нее. **Первое нажатие** откроет терминал, а **второе нажатие** запустит ее. 

И теперь создадим под, для этого **запустим команду**`kubectl apply -f pod.yaml`  в первом терминале. 

И в **соседнем терминале** будем следить за статусом. Да, под создался. Теперь **дождемся** пока у пода не станет статус Running.

После того, как под запустился, можно посмотреть логи контейнера пода с помощью команды `kubectl logs hello-demo`

**Запускаем команду.** 

И видим логи старта приложения.

Также kubectl позволяет выполнить в контейнере пода команду с помощью kubectl exec.  

**Запустим** bash в поде`hello-demo`.

И например, посмотрим переменные окружения контейнера с помощью **команды** env.

Чтобы выйти из интеративного режима, надо нажать сочетание клавиш **Ctrl-D**

Попробуем посмотреть, как отвечает сервис, и для этого получить доступ к *поду* по **ip**. Найдем **ip** пода командой describe. **Запускаем ее**. И вот здесь можем увидеть не только ip пода, но и например, события, связанные с подом и другую метаинформацию.

Также мы можем получить полностью развернутую информацию о *поде* в **json** формате. 

**Запускаем команду.**

И вот здесь тоже можно видеть IP пода. 

Для работы в скриптах бывает полезно и удобно использовать формат вывода jsonpath. Он позволяет вывести только ту часть json-а, которая нам нужна. 

**Запустим команду.** 

Эта команда выведет нам только IP пода. 
Давайте ее сохраним в переменную окружения POD_ID.

**Запускаем команду.** 

И теперь по этому IP мы можем обратиться к *поду* с управляющей ноды с помощью утилиты curl. 

**Очистим терминал и запустим команду.**

В результате выполнения curl вернул строку `"Hello world from hello-demo!"`

Также можем сделать запрос к ендпоинту /version. 

**Запускаем команду.**

В результате выполнение curl должен вернуть строку с версией приложения.

Посмотрим логи пода с помощью **команды**`kubectl logs hello-demo`

Видим логи запросов, которые мы только что произвели.

Ну и теперь можем удалить *под* с помощью команды kubectl delete pod hello-demo. **Запустим ее.** 

Удалятся *под* может достаточно долго, до минуты.

Можем отслеживать статус *пода* во **втором терминале,** пока объект совсем не будет удален.

Помимо декларативных команд, **kubectl** поддерживает и так называемые *императивные команды*. 

Например, можно было запустить такую же рабочую нагркузу с помощью команды kubectl run. 

**Запустим ее.**

При выполнении этой команды создастся *под* с именем `hello-demo`, у которого в определении контейнеров будет только один с указанным образом нашего приложения. 

**Во втором терминале** можно увидеть, как это под создается и запускается.  

Императивные команды kubectl считаются менее идиоматическими, и например команда kubectl run в будущих версиях вообще исчезнет. 

Теперь давайте удалим пространство имен **myapp**. И оно приведет к удалению и всех объектов, которые в нем находятся.

**Запускаем команду**  kubectl delete ns myapp

За процессом удаления можно следить во **втором терминале.**

Итак, мы с вами познакомились с основными командами kubectl для работы с подами. 