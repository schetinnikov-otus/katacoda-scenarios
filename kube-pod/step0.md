Сначала запустим кластер Kubernetes. Для этого нужно дождаться выполнения команды:

`./launch_k8s.sh`{{execute}}

Посмотрим, на скольких нодах у нас развернут кластер: 

`kubectl get node`{{execute}}

Кластер у нас небольшой, но настоящий - состоит из 2ух нод - одной управляющей ноды и одной рабочей. Управляющая нода имеет имя хоста - controlplane, а рабочая - node01. Давайте зайдем на рабочую ноду. 

Давайте посмотрим список namespace-ов

`kubectl get namespace`{{execute}}

Видим несколько системных namespace-ов, в частности kube-system, в котором запущены основные управляющие компоненты кластера Kubernetes. Они запущены в виде подов. Список под в пространстве имен kube-system, можно посмотреть с помощью команды:

`kubectl get pods -n kube-system`{{execute}}

Помимо стандартных управляющих комопнент, можно увидеть сетевой плагин - flannel, компонент для работы с DNS - coredns и т.д.

Давайте с вами создадим свой namespace, в котором будем работать:

`kubectl create namespace myapp`{{execute}}

Чтобы каждый раз не вводить название namespace-а в командах kubectl изменим контекст:

`kubectl config set-context --current --namespace=myapp`{{execute}}

Давайте создадим под, для этого воспользуемся простейшим приложением на питоне, у которого есть несколько эндпоинтов, на которые он отвечает:

/ - Пишет Hello from <название хоста>

/version - Отдает версию приложения

/health - Если приложение работает, отвечает {"status": "ok"} 

Для этого создадим файл pod.yaml с манифестом кубернетес. Это будет простейшее описание объекта типа Pod.

<pre class="file" data-filename="./pod.yaml" data-target="replace">
apiVersion: v1
kind: Pod
metadata:
  name: hello-demo
spec:
  containers:
  - name: hello-demo
    image: schetinnikov/hello-app:v1
    ports:
      - containerPort: 8000
</pre>

И теперь создадим под, для этого запустим в первом терминале:

`kubectl apply -f pod.yaml`{{execute T1}}

С помощью команды можем отслеживать статус подов, которые находятся в нашем неймспейсе.

`watch kubectl get pods`{{execute T2}}

(если терминал не был до этого открыт, то команду нужно будет нажать 2 раза - первый раз будет открыт терминал, а во второй выполнится уже команда)

Дождемся, пока у пода не станет статус Running.

После этого можно посмотреть логи контейнера внутри пода 

`kubectl logs hello-demo`{{execute T1}}

И например, "зайти" внутрь пода и выполнить в контейнере команду в интерактивном режим 

`kubectl exec -it hello-demo -- /bin/bash`{{execute T1}}

`env`{{execute T1}}

Чтобы выйти, надо нажать Ctrl-C

`^C`{{execute ctrl-seq}}

(если терминал не был до этого открыт, то команду нужно будет нажать 2 раза - первый раз будет открыт терминал, а во второй выполнится уже команда)

Попробуем получить доступ к поду по ip. Для этого, вытаскиваем ip командой describe 

`kubectl describe pod hello-demo`{{execute T1}}

Также мы можем получить полностью развернутую информацию о поде в json формате:

`kubectl get -o json pod hello-demo | jq`{{execute}}

Также с помощью формата вывода jsonpath можем доставать любую информацию о поде. Это крайне полезно и удобно для работы в скриптах.

`kubectl get -o jsonpath='{.status.podIP}' pod hello-demo`{{execute}}

Давайте сохраним IP пода в переменную

`POD_IP=$(kubectl get -o jsonpath='{.status.podIP}' pod hello-demo)`{{execute}}

И теперь по этому IP мы можем обратиться к поду

`curl http://$POD_IP:8000/`{{execute}}

И теперь можем удалить под:

`kubectl delete -f pod.yaml`{{execute T1}}

Удалятся под может достаточно долго (до минуты)

С помощью команды можем отслеживать статус пода во втором терминале

Помимо декларативных команд, kubectl поддерживает и так называемые императивные команды.

Например, можно было запустить такую же рабочую нагркузу с помощью команды: 

`kubectl run hello-demo --image=schetinnikov/hello-app:v1`{{execute T1}}

Конечно же, запускается при этом не голый контейнер. При выполнении этой команды создастся под с именем hello-demo, у которого в определении контейнеров будет только один с образом schetinnikov/hello-app:v1.

`kubectl get po`{{execute T1}}

Теперь давайте удалим пространство имен myapp. И оно приведет к удалению и всех объектов, которые в нем находятся.

`kubectl delete ns myapp`{{execute T1}}

За процессом можно следить во втором терминале.
