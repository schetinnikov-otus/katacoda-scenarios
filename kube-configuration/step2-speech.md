Передавать конфигурацию через **env** не всегда удобно. Т.к. для разных сред, конфигурация может отличаться, а значит, придется хранить несколько версий манифеста одного и того же деплоймента, но с разными настройками.  Также хранение конфигов напрямую в деплойментах нарушает один из принципов  12 факторных приложений. В соответствии с ним, мы должны отделять конфигурацию приложения от артефактов билда и деплоя.

Поэтому в Kubernetes есть объекты ConfigMap и Secret, которые позволяют хранить конфигурацию приложения отдельно от манифестов приложения.

Для начала рассмотрим как можно создавать ConfigMap и Secret-ы. 

Прежде всего, ConfigMap и Secret, как и любые объекты в Kubernetes можно описать в файле и потом применить манифест. 

Давайте **создадим файл configmap.yaml** с описанием ConfigMap. 

Помимо стандартных атрибутов apiVersion, kind, metadata в конфигмапе есть атрибут data, где хранятся данные конфигурации. 


Применим манифест **configmap.yaml**: 

Как и любой объект Kubernetes, ConfigMap можно получить 

**Запускаем команду.** 

Видим скудную информацию о ConfigMapе.

Чтобы получить больше данных, можно использовать команду kubectl describe 

**Запускаем команду**

И можем посмотреть в том числе данные конфигурации. 

Теперь посмотрим с вами Secret.  

Создадим манифест **secret.yaml**

Структура такая же как и у конфигмапы. Но есть существенное отличие: данные в объекте ConfigMap хранятся как есть, а в Secret-е кодируются в base64 . 

Например, значение `DATABASE_URI` закодировано в base64.

Давайте с вами раскодируем значение из DATABASE_URI:

**Запускаем команду.** 

И видим, что это действительно base64

И когда мы создаем Secret с помощью манифестов, то кодировать нужно самостоятельно. Например, с помощью утилиты base64: 

**Запустим команду**  

И действительно это ровно то значение, которое у нас используется в манифесте. 

Применим манифест **secret.yaml**: 

**Получить Secret** можно также как и любой объект:

Если мы сделаем kubectl describe, то данных из Secret-а мы не получим. 

**Запускаем команду** 

И видим с вами только ключи, значений не видим.

Но если запросить в формате yaml или json, то там будет закодированная строка

**Запускаем команды**

И видим там закодированные в base64 значения. 

Чтобы получить значение конкретного параметра Secret-а из командной строки, можно воспользоваться параметром jsonpath и base64:

**Запускаем команду** 

И таким образом получаем конкретное значение параметра.

Помимо манифестов, мы можем создать ConfigMap и Secret с помощью *императивных* команд.  Самый простой способ создать эти объекты из строковых литералов.

Например, ConfigMap можно создать с помощью такой команды kubectl create configmap {имя конфигмапы} --from-literal

Давайте создадим конфигмапу hello-config-literal с двумя параметрами - GREETING  и GREETING2 

**Запускаем команду**

И проверим, что ConfigMap создался правильно

**Запускаем команду.**

Да, все создалось, как надо.

Команда для создания секретов из литералов выглядит очень похоже на конфигмапы - kubectl create secret generic {имя секрета} --from-literal=ключ-значение. 

Давайте создадим секрет с `PASSWORD=SuperCoolPassword2`. 

Данные в команду передаются чистые, незакодированные,  Kubernetes сам занимается их кодированием

**Запускаем команду**

Все отработало. 

Проверим, что данные закодированы.

**Запускаем команду:**

Да, там действительно base64

Раскодируем base64 и удостоверимся, что данные совпадают с теми, что мы отправляли в команде

**Запускаем команду** 

Да, действительно совпадают. 

Теперь удалим Secret и ConfigMap, чтобы они нам не мешали

**Запускаем команды.** 

Есть еще возможность создавать ConfigMap и Secret из файлов. В общем случае передается имя директории. И для каждого файла создается пара, где ключом является имя файла, а значением - его содержимое. И для секретов и для конфигмап значения передаются чистые, незакодированные.

Давайте с вами создадим директорию `hello-configmap-dir`, а в ней файлы `GREETING` и `GREETING2`

**Запускаем команды.**

Теперь с помощью команды `kubectl create configmap {имя конфигмапы} --from-file=`  мы  можем создать ConfigMap:

**Запускаем команду.** 

**Проверяем**, что ConfigMap :

Да, действительно, все создалось как надо. 

Для Secret-ов это работает аналогично:

Давайте с вами создадим директорию `hello-secret-dir`, а в ней файл `DATABASE_URI` и `PASSWORD`. В содержимом файла должны хранится данные в незакодированном виде

**Запускаем команды.** 

Теперь с помощью команды `kubectl create secret generic {имя секрета} --from-file=`  мы можем создать секрет. 

**Запускаем команду.** 

Проверим, что данные закодированы:

**Запускаем команды.**

Да все закодировано. 

И проверим, что совпадают с теми данными, что мы отправляли в команде.

**Запускаем команду.**

Да, на самом деле совпадают. 

Теперь удалим Secret и ConfigMap, чтобы они нам не мешали.

**Запускаем команду.** 

Итак, мы с вами рассмотрели несколько вариантов создания конфигмапов и секретов. Теперь давайте посмотрим, как их можно использовать в манифестах. 