Один из самых простых способов конфигурации приложения - это через переменные окружения. Давайте познакомимся с тем, как работать с переменными окружения в Kubernetes. 

Прежде всего запустим приложение. Для этого создадим уже знакомые нам deployment.yaml и service.yaml

**Создаем deployment.yaml** Единственное отличие этого деплоймента от остальных сценариев - это используемая версия приложения. Тут используется версия 3 сервиса, которая по урлу /env отдает свою конфигурацию. 

**Создаем service.yaml** 

**Применяем манифесты**

**Во втором терминал**е можем наблюдать за тем, как создаются *поды*. 
Дождемся, пока *деплоймент* раскатится - т.е. когда все *поды* окажутся в статусе Running

Итак, как я уже сказал, мы используем версию приложения, которая по пути`/env` отдает свою конфигурацию

Давайте сделаем запрос к приложению и посмотрим на настройки по умолчанию. 

Сохраним clusterIp *сервиса* в переменную `CLUSTER_IP`

**Запускаем команду.** 

И **делаем запрос на слэш env**.  Смотрим ответ приложения:

Видим с вами три переменных конфигурации DATABASE_URI, GREETING, HOSTNAME. DATABASE_URI и GREETING берутся из переменных окружения, а HOSTNAME - это имя хоста приложения. 

Значения, которые мы с вами видим - это значения по умолчанию, т.е. когда никаких переменных окружения не выставлено.  

Давайте переопределим DATABASE_URI и GREETING. Добавим в явном виде секцию env в спецификацию контейнера. В этой секции можно перечислить набор пар name-value. В результате контейнеру при запуске будут добавлены перменные окружения с именем из name и значением из value.  

Добавляем эту секцию в наш **deployment.yaml**

И добавляем переменные окружения DATABASE_URI и GREETING. 

**Применяем манифест**

Во втором терминале можем наблюдать за тем, как создаются *поды*. 
Дождемся, пока *деплоймент* раскатится.

Все, раскатился. 

**Делаем запрос**

И видим, что те переменные которые мы передали подхватываются в конфигурации приложения. 

